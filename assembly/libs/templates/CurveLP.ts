// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from '@graphprotocol/graph-ts'

export class Approval extends ethereum.Event {
  get params(): Approval__Params {
    return new Approval__Params(this)
  }
}

export class Approval__Params {
  _event: Approval

  constructor(event: Approval) {
    this._event = event
  }

  get _owner(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get _spender(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get _value(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class Transfer extends ethereum.Event {
  get params(): Transfer__Params {
    return new Transfer__Params(this)
  }
}

export class Transfer__Params {
  _event: Transfer

  constructor(event: Transfer) {
    this._event = event
  }

  get _from(): Address {
    return this._event.parameters[0].value.toAddress()
  }

  get _to(): Address {
    return this._event.parameters[1].value.toAddress()
  }

  get _value(): BigInt {
    return this._event.parameters[2].value.toBigInt()
  }
}

export class CurveLP extends ethereum.SmartContract {
  static bind(address: Address): CurveLP {
    return new CurveLP('CurveLP', address)
  }

  transfer(_to: Address, _value: BigInt): boolean {
    let result = super.call('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])

    return result[0].toBoolean()
  }

  try_transfer(_to: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('transfer', 'transfer(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  transferFrom(_from: Address, _to: Address, _value: BigInt): boolean {
    let result = super.call(
      'transferFrom',
      'transferFrom(address,address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    )

    return result[0].toBoolean()
  }

  try_transferFrom(
    _from: Address,
    _to: Address,
    _value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      'transferFrom',
      'transferFrom(address,address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_from),
        ethereum.Value.fromAddress(_to),
        ethereum.Value.fromUnsignedBigInt(_value)
      ]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  approve(_spender: Address, _value: BigInt): boolean {
    let result = super.call('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])

    return result[0].toBoolean()
  }

  try_approve(_spender: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('approve', 'approve(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_spender),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  permit(
    _owner: Address,
    _spender: Address,
    _value: BigInt,
    _deadline: BigInt,
    _v: i32,
    _r: Bytes,
    _s: Bytes
  ): boolean {
    let result = super.call(
      'permit',
      'permit(address,address,uint256,uint256,uint8,bytes32,bytes32):(bool)',
      [
        ethereum.Value.fromAddress(_owner),
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromUnsignedBigInt(_deadline),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_v)),
        ethereum.Value.fromFixedBytes(_r),
        ethereum.Value.fromFixedBytes(_s)
      ]
    )

    return result[0].toBoolean()
  }

  try_permit(
    _owner: Address,
    _spender: Address,
    _value: BigInt,
    _deadline: BigInt,
    _v: i32,
    _r: Bytes,
    _s: Bytes
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      'permit',
      'permit(address,address,uint256,uint256,uint8,bytes32,bytes32):(bool)',
      [
        ethereum.Value.fromAddress(_owner),
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_value),
        ethereum.Value.fromUnsignedBigInt(_deadline),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_v)),
        ethereum.Value.fromFixedBytes(_r),
        ethereum.Value.fromFixedBytes(_s)
      ]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  increaseAllowance(_spender: Address, _added_value: BigInt): boolean {
    let result = super.call(
      'increaseAllowance',
      'increaseAllowance(address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_added_value)
      ]
    )

    return result[0].toBoolean()
  }

  try_increaseAllowance(
    _spender: Address,
    _added_value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      'increaseAllowance',
      'increaseAllowance(address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_added_value)
      ]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  decreaseAllowance(_spender: Address, _subtracted_value: BigInt): boolean {
    let result = super.call(
      'decreaseAllowance',
      'decreaseAllowance(address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_subtracted_value)
      ]
    )

    return result[0].toBoolean()
  }

  try_decreaseAllowance(
    _spender: Address,
    _subtracted_value: BigInt
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      'decreaseAllowance',
      'decreaseAllowance(address,uint256):(bool)',
      [
        ethereum.Value.fromAddress(_spender),
        ethereum.Value.fromUnsignedBigInt(_subtracted_value)
      ]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  mint(_to: Address, _value: BigInt): boolean {
    let result = super.call('mint', 'mint(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])

    return result[0].toBoolean()
  }

  try_mint(_to: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('mint', 'mint(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  mint_relative(_to: Address, frac: BigInt): BigInt {
    let result = super.call(
      'mint_relative',
      'mint_relative(address,uint256):(uint256)',
      [ethereum.Value.fromAddress(_to), ethereum.Value.fromUnsignedBigInt(frac)]
    )

    return result[0].toBigInt()
  }

  try_mint_relative(_to: Address, frac: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'mint_relative',
      'mint_relative(address,uint256):(uint256)',
      [ethereum.Value.fromAddress(_to), ethereum.Value.fromUnsignedBigInt(frac)]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  burnFrom(_to: Address, _value: BigInt): boolean {
    let result = super.call('burnFrom', 'burnFrom(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])

    return result[0].toBoolean()
  }

  try_burnFrom(_to: Address, _value: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall('burnFrom', 'burnFrom(address,uint256):(bool)', [
      ethereum.Value.fromAddress(_to),
      ethereum.Value.fromUnsignedBigInt(_value)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBoolean())
  }

  decimals(): i32 {
    let result = super.call('decimals', 'decimals():(uint8)', [])

    return result[0].toI32()
  }

  try_decimals(): ethereum.CallResult<i32> {
    let result = super.tryCall('decimals', 'decimals():(uint8)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toI32())
  }

  version(): string {
    let result = super.call('version', 'version():(string)', [])

    return result[0].toString()
  }

  try_version(): ethereum.CallResult<string> {
    let result = super.tryCall('version', 'version():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  name(): string {
    let result = super.call('name', 'name():(string)', [])

    return result[0].toString()
  }

  try_name(): ethereum.CallResult<string> {
    let result = super.tryCall('name', 'name():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  symbol(): string {
    let result = super.call('symbol', 'symbol():(string)', [])

    return result[0].toString()
  }

  try_symbol(): ethereum.CallResult<string> {
    let result = super.tryCall('symbol', 'symbol():(string)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toString())
  }

  DOMAIN_SEPARATOR(): Bytes {
    let result = super.call(
      'DOMAIN_SEPARATOR',
      'DOMAIN_SEPARATOR():(bytes32)',
      []
    )

    return result[0].toBytes()
  }

  try_DOMAIN_SEPARATOR(): ethereum.CallResult<Bytes> {
    let result = super.tryCall(
      'DOMAIN_SEPARATOR',
      'DOMAIN_SEPARATOR():(bytes32)',
      []
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBytes())
  }

  balanceOf(arg0: Address): BigInt {
    let result = super.call('balanceOf', 'balanceOf(address):(uint256)', [
      ethereum.Value.fromAddress(arg0)
    ])

    return result[0].toBigInt()
  }

  try_balanceOf(arg0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('balanceOf', 'balanceOf(address):(uint256)', [
      ethereum.Value.fromAddress(arg0)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  allowance(arg0: Address, arg1: Address): BigInt {
    let result = super.call(
      'allowance',
      'allowance(address,address):(uint256)',
      [ethereum.Value.fromAddress(arg0), ethereum.Value.fromAddress(arg1)]
    )

    return result[0].toBigInt()
  }

  try_allowance(arg0: Address, arg1: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      'allowance',
      'allowance(address,address):(uint256)',
      [ethereum.Value.fromAddress(arg0), ethereum.Value.fromAddress(arg1)]
    )
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  totalSupply(): BigInt {
    let result = super.call('totalSupply', 'totalSupply():(uint256)', [])

    return result[0].toBigInt()
  }

  try_totalSupply(): ethereum.CallResult<BigInt> {
    let result = super.tryCall('totalSupply', 'totalSupply():(uint256)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }

  minter(): Address {
    let result = super.call('minter', 'minter():(address)', [])

    return result[0].toAddress()
  }

  try_minter(): ethereum.CallResult<Address> {
    let result = super.tryCall('minter', 'minter():(address)', [])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toAddress())
  }

  nonces(arg0: Address): BigInt {
    let result = super.call('nonces', 'nonces(address):(uint256)', [
      ethereum.Value.fromAddress(arg0)
    ])

    return result[0].toBigInt()
  }

  try_nonces(arg0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall('nonces', 'nonces(address):(uint256)', [
      ethereum.Value.fromAddress(arg0)
    ])
    if (result.reverted) {
      return new ethereum.CallResult()
    }
    let value = result.value
    return ethereum.CallResult.fromValue(value[0].toBigInt())
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this)
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this)
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall

  constructor(call: ConstructorCall) {
    this._call = call
  }
}

export class TransferCall extends ethereum.Call {
  get inputs(): TransferCall__Inputs {
    return new TransferCall__Inputs(this)
  }

  get outputs(): TransferCall__Outputs {
    return new TransferCall__Outputs(this)
  }
}

export class TransferCall__Inputs {
  _call: TransferCall

  constructor(call: TransferCall) {
    this._call = call
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class TransferCall__Outputs {
  _call: TransferCall

  constructor(call: TransferCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class TransferFromCall extends ethereum.Call {
  get inputs(): TransferFromCall__Inputs {
    return new TransferFromCall__Inputs(this)
  }

  get outputs(): TransferFromCall__Outputs {
    return new TransferFromCall__Outputs(this)
  }
}

export class TransferFromCall__Inputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get _from(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _to(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }
}

export class TransferFromCall__Outputs {
  _call: TransferFromCall

  constructor(call: TransferFromCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class ApproveCall extends ethereum.Call {
  get inputs(): ApproveCall__Inputs {
    return new ApproveCall__Inputs(this)
  }

  get outputs(): ApproveCall__Outputs {
    return new ApproveCall__Outputs(this)
  }
}

export class ApproveCall__Inputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class ApproveCall__Outputs {
  _call: ApproveCall

  constructor(call: ApproveCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class PermitCall extends ethereum.Call {
  get inputs(): PermitCall__Inputs {
    return new PermitCall__Inputs(this)
  }

  get outputs(): PermitCall__Outputs {
    return new PermitCall__Outputs(this)
  }
}

export class PermitCall__Inputs {
  _call: PermitCall

  constructor(call: PermitCall) {
    this._call = call
  }

  get _owner(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _spender(): Address {
    return this._call.inputValues[1].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[2].value.toBigInt()
  }

  get _deadline(): BigInt {
    return this._call.inputValues[3].value.toBigInt()
  }

  get _v(): i32 {
    return this._call.inputValues[4].value.toI32()
  }

  get _r(): Bytes {
    return this._call.inputValues[5].value.toBytes()
  }

  get _s(): Bytes {
    return this._call.inputValues[6].value.toBytes()
  }
}

export class PermitCall__Outputs {
  _call: PermitCall

  constructor(call: PermitCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class IncreaseAllowanceCall extends ethereum.Call {
  get inputs(): IncreaseAllowanceCall__Inputs {
    return new IncreaseAllowanceCall__Inputs(this)
  }

  get outputs(): IncreaseAllowanceCall__Outputs {
    return new IncreaseAllowanceCall__Outputs(this)
  }
}

export class IncreaseAllowanceCall__Inputs {
  _call: IncreaseAllowanceCall

  constructor(call: IncreaseAllowanceCall) {
    this._call = call
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _added_value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class IncreaseAllowanceCall__Outputs {
  _call: IncreaseAllowanceCall

  constructor(call: IncreaseAllowanceCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class DecreaseAllowanceCall extends ethereum.Call {
  get inputs(): DecreaseAllowanceCall__Inputs {
    return new DecreaseAllowanceCall__Inputs(this)
  }

  get outputs(): DecreaseAllowanceCall__Outputs {
    return new DecreaseAllowanceCall__Outputs(this)
  }
}

export class DecreaseAllowanceCall__Inputs {
  _call: DecreaseAllowanceCall

  constructor(call: DecreaseAllowanceCall) {
    this._call = call
  }

  get _spender(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _subtracted_value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class DecreaseAllowanceCall__Outputs {
  _call: DecreaseAllowanceCall

  constructor(call: DecreaseAllowanceCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class MintCall extends ethereum.Call {
  get inputs(): MintCall__Inputs {
    return new MintCall__Inputs(this)
  }

  get outputs(): MintCall__Outputs {
    return new MintCall__Outputs(this)
  }
}

export class MintCall__Inputs {
  _call: MintCall

  constructor(call: MintCall) {
    this._call = call
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class MintCall__Outputs {
  _call: MintCall

  constructor(call: MintCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class Mint_relativeCall extends ethereum.Call {
  get inputs(): Mint_relativeCall__Inputs {
    return new Mint_relativeCall__Inputs(this)
  }

  get outputs(): Mint_relativeCall__Outputs {
    return new Mint_relativeCall__Outputs(this)
  }
}

export class Mint_relativeCall__Inputs {
  _call: Mint_relativeCall

  constructor(call: Mint_relativeCall) {
    this._call = call
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get frac(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class Mint_relativeCall__Outputs {
  _call: Mint_relativeCall

  constructor(call: Mint_relativeCall) {
    this._call = call
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt()
  }
}

export class BurnFromCall extends ethereum.Call {
  get inputs(): BurnFromCall__Inputs {
    return new BurnFromCall__Inputs(this)
  }

  get outputs(): BurnFromCall__Outputs {
    return new BurnFromCall__Outputs(this)
  }
}

export class BurnFromCall__Inputs {
  _call: BurnFromCall

  constructor(call: BurnFromCall) {
    this._call = call
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress()
  }

  get _value(): BigInt {
    return this._call.inputValues[1].value.toBigInt()
  }
}

export class BurnFromCall__Outputs {
  _call: BurnFromCall

  constructor(call: BurnFromCall) {
    this._call = call
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean()
  }
}

export class InitializeCall extends ethereum.Call {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this)
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this)
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }

  get _name(): string {
    return this._call.inputValues[0].value.toString()
  }

  get _symbol(): string {
    return this._call.inputValues[1].value.toString()
  }

  get _pool(): Address {
    return this._call.inputValues[2].value.toAddress()
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall

  constructor(call: InitializeCall) {
    this._call = call
  }
}
